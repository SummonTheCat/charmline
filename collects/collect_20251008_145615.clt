
================================================================================
# FILE: ./src\main.rs
================================================================================

// ----- Modules ----- //
// Global Systems
mod sys_resource;
// Component Systems
mod sys_core;
mod sys_bot;
// ----- Imports ----- //
use crate::sys_core::{Server, load_config};
// ----- Lifecycle ----- //
fn main() {
    load_config("cfg/config.json");
    let address = "127.0.0.1:8080";
    let server = Server::new(address, "static");
    server.run();
}

================================================================================
# FILE: ./src\sys_resource.rs
================================================================================

// ----- Imports ----- //
use std::{
    collections::HashMap,
    env,
    fs,
    path::{Path, PathBuf},
    sync::{Arc, Mutex},
};
// ----- Structures ----- //
#[derive(Clone)]
pub struct CachedFile {
    pub bytes: Vec<u8>
}
pub struct CachedLoader {
    cache: Arc<Mutex<HashMap<String, CachedFile>>>,
    root_dir: PathBuf,
}
// ----- Implementations ----- //
impl CachedLoader {
    // Initialize a new CachedLoader with a specified base directory
    pub fn new(base_dir: impl AsRef<Path>) -> Self {
        let exe_path = env::current_exe().expect("Failed to get current executable path");
        let exe_dir = exe_path.parent().expect("Executable should have a parent directory");
        let root_dir = exe_dir.join(base_dir.as_ref());
        Self {
            cache: Arc::new(Mutex::new(HashMap::new())),
            root_dir,
        }
    }
    // Load a file from the cache or filesystem
    pub fn load(&self, filename: &str) -> Option<CachedFile> {
        if let Some(cached) = self.cache.lock().unwrap().get(filename).cloned() {
            return Some(cached);
        }
        let path = self.root_dir.join(filename);
        match fs::read(&path) {
            Ok(bytes) => {
                let cached_file = CachedFile { bytes: bytes.clone() };
                self.cache
                    .lock()
                    .unwrap()
                    .insert(filename.to_string(), cached_file.clone());
                println!("Cached file: {:?}", path);
                Some(cached_file)
            }
            Err(_) => None,
        }
    }
}

================================================================================
# FILE: ./src\sys_bot\bot_handlers.rs
================================================================================

use crate::sys_core::{core_responses::response_ok, openai::ask_openai, HttpResponse};
use serde_json::Value;
use crate::sys_core::get_config;
// ----- API Handlers ----- //
pub fn handle_api_command(body: &str) -> HttpResponse {
    let parsed: Option<String> = serde_json::from_str::<Value>(body).ok().and_then(|v| {
        v.get("command")
            .and_then(|c| c.as_str())
            .map(|s| s.to_string())
    });
    let cmd = parsed.unwrap_or_else(|| "<empty>".to_string());
    let (cmd_name, args) = parse_command(&cmd);
    let msg = execute_command(&cmd_name, &args);
    response_ok("application/json; charset=utf-8", msg.into_bytes())
}
// ----- Command Dispatch ----- //
fn parse_command(input: &str) -> (String, Vec<String>) {
    let mut parts = input.split_whitespace();
    let cmd = parts.next().unwrap_or("").to_string();
    let args = parts.map(|s| s.to_string()).collect();
    (cmd, args)
}
fn execute_command(_cmd: &str, _args: &[String]) -> String {
    // Switch for command execution logic
    let response = match _cmd {
        "help" => command_help(_args),
        "test" => command_test(_args),
        _ => command_not_supported(_cmd, _args),
    };
    response
}
// ----- Command Implementations ----- //
fn command_help(_args: &[String]) -> String {
    r#"{"message":"Available commands: help, test"}"#.to_string()
}
fn command_not_supported(cmd: &str, _args: &[String]) -> String {
    format!(r#"{{"message":"Command not supported: {}"}}"#, cmd)
}
// ----- Tests ----- //
fn command_test(args: &[String]) -> String {
    // Switch on the args for the test target
    let response = match args.get(0).map(String::as_str) {
        Some("echo") => command_test_echo(&args[1..]),
        _ => r#"{"message":"Test what? Available: echo"}"#.to_string(),
    };
    response
}
fn command_test_echo(args: &[String]) -> String {
    let input = args.join(" ");
    let mut result = format!(r#"{{"message":"Echo: {}"}}"#, input);
    if !input.trim().is_empty() {
        match ask_openai(&input) {
            Ok(reply) => {
                result = format!(r#"{{"message":"AI: {}"}}"#, reply.replace('"', "\\\""));
            }
            Err(err) => {
                result = format!(r#"{{"message":"OpenAI Error: {}"}}"#, err);
            }
        }
    }
    result
}

================================================================================
# FILE: ./src\sys_bot\mod.rs
================================================================================

pub mod bot_handlers;

================================================================================
# FILE: ./src\sys_core\config.rs
================================================================================

use serde::Deserialize;
use std::fs;
use std::sync::OnceLock;
#[derive(Debug, Deserialize)]
pub struct AppConfig {
    #[serde(rename = "botAPIKey")]
    pub bot_apikey: String,
    //#[serde(rename = "botTarget")]
    //pub bot_target: String,
}
static CONFIG: OnceLock<AppConfig> = OnceLock::new();
pub fn load_config(path: &str) {
    let contents = fs::read_to_string(path).expect(&format!("Failed to read config file {}", path));
    let parsed: AppConfig = serde_json::from_str(&contents).expect("Invalid config format");
    CONFIG.set(parsed).expect("Config already initialized");
}
pub fn get_config() -> &'static AppConfig {
    CONFIG.get().expect("Config not initialized")
}

================================================================================
# FILE: ./src\sys_core\core_responses.rs
================================================================================

// ----- Imports ----- //
use crate::sys_core::core_routing::HttpResponse;
// ----- Responses ----- //
pub fn response_ok(content_type: &'static str, body: Vec<u8>) -> HttpResponse {
    HttpResponse {
        status_line: "HTTP/1.1 200 OK",
        content_type,
        body,
    }
}
pub fn response_not_found(msg: &str) -> HttpResponse {
    HttpResponse {
        status_line: "HTTP/1.1 404 NOT FOUND",
        content_type: "text/plain; charset=utf-8",
        body: msg.as_bytes().to_vec(),
    }
}
pub fn response_method_not_allowed() -> HttpResponse {
    HttpResponse {
        status_line: "HTTP/1.1 405 METHOD NOT ALLOWED",
        content_type: "text/plain; charset=utf-8",
        body: b"Method not allowed".to_vec(),
    }
}

================================================================================
# FILE: ./src\sys_core\core_routing.rs
================================================================================

// ----- Imports ----- //
use std::path::Path;
use std::sync::Arc;
use crate::sys_bot::bot_handlers::handle_api_command;
use crate::sys_core::core_responses::{response_not_found, response_ok};
use crate::sys_resource::CachedLoader;
// ----- Structs ----- //
pub struct HttpResponse {
    pub status_line: &'static str,
    pub content_type: &'static str,
    pub body: Vec<u8>,
}
// ----- Implementations ----- //
impl HttpResponse {
    pub fn to_bytes(&self) -> Vec<u8> {
        let header = format!(
            "{}\r\nContent-Length: {}\r\nContent-Type: {}\r\n\r\n",
            self.status_line,
            self.body.len(),
            self.content_type
        );
        let mut response = header.into_bytes();
        response.extend_from_slice(&self.body);
        response
    }
}
// ----- Routing ----- //
pub fn handle_route(path: &str, loader: &Arc<CachedLoader>, body: &str) -> HttpResponse {
    match path {
        "/" => match loader.load("index.html") {
            Some(file) => response_ok("text/html", file.bytes),
            None => response_not_found("index.html not found"),
        },
        "/api/cmd" => handle_api_command(body),
        _ => serve_static(path, loader),
    }
}
// Serve static files (html, css, js, images, etc.)
fn serve_static(path: &str, loader: &Arc<CachedLoader>) -> HttpResponse {
    let path = path.trim_start_matches('/');
    if path.contains("..") {
        return response_not_found("Invalid path");
    }
    let content_type = content_type_for(path);
    match loader.load(path) {
        Some(file) => response_ok(content_type, file.bytes),
        None => response_not_found("File not found"),
    }
}
// ----- Helpers ----- //
fn content_type_for(path: &str) -> &'static str {
    match Path::new(path).extension().and_then(|e| e.to_str()).unwrap_or("") {
        "html" => "text/html; charset=utf-8",
        "css" => "text/css; charset=utf-8",
        "js" => "application/javascript; charset=utf-8",
        "jpg" | "jpeg" => "image/jpeg",
        "png" => "image/png",
        "svg" => "image/svg+xml",
        "ico" => "image/x-icon",
        _ => "application/octet-stream",
    }
}

================================================================================
# FILE: ./src\sys_core\core_server.rs
================================================================================

// ----- Imports ----- //
use std::{
    io::{Read, Write},
    net::{TcpListener, TcpStream},
    sync::Arc,
    thread,
};
use crate::{
    sys_core::{
        core_responses::response_method_not_allowed,
        core_routing::handle_route,
    },
    sys_resource::CachedLoader,
};
// ----- Structs ----- //
pub struct Server {
    address: String,
    loader: Arc<CachedLoader>,
}
// ----- Implementations ----- //
impl Server {
    pub fn new(address: &str, base_dir: &str) -> Self {
        let loader = Arc::new(CachedLoader::new(base_dir));
        Self {
            address: address.to_string(),
            loader,
        }
    }
    pub fn run(&self) {
        let listener = TcpListener::bind(&self.address).expect("Failed to bind port");
        println!("Charmline running at http://{}/", self.address);
        for stream in listener.incoming() {
            if let Ok(stream) = stream {
                let loader = Arc::clone(&self.loader);
                thread::spawn(move || handle_client(stream, loader));
            }
        }
    }
}
// ----- Lifecycle ----- //
fn handle_client(mut stream: TcpStream, loader: Arc<CachedLoader>) {
    let mut buffer = [0; 8192];
    let bytes_read = match stream.read(&mut buffer) {
        Ok(size) => size,
        Err(_) => return,
    };
    let request = String::from_utf8_lossy(&buffer[..bytes_read]);
    // Parse the request line
    let mut lines = request.lines();
    let first_line = lines.next().unwrap_or("");
    let mut parts = first_line.split_whitespace();
    let method = parts.next().unwrap_or("");
    let path = parts.next().unwrap_or("/");
    // Extract body (after a blank line)
    let body_start = request.find("\r\n\r\n").map(|i| i + 4);
    let body = body_start
        .map(|i| request[i..].to_string())
        .unwrap_or_default();
    let response = match method {
        "GET" | "POST" => handle_route(path, &loader, &body),
        _ => response_method_not_allowed(),
    };
    let _ = stream.write_all(&response.to_bytes());
}

================================================================================
# FILE: ./src\sys_core\mod.rs
================================================================================

// ----- Private Modules ----- //
mod core_routing;
mod core_server;
// ----- Public Modules ----- //
pub mod config;
pub mod core_responses;
pub mod openai;
// ----- Exports ----- //
pub use core_server::Server;
pub use core_routing::HttpResponse;
pub use config::{load_config, get_config};

================================================================================
# FILE: ./src\sys_core\openai.rs
================================================================================

use crate::sys_core::get_config;
use serde::{Deserialize, Serialize};
#[derive(Serialize, Deserialize)]
struct OpenAIMessage {
    role: String,
    content: String,
}
#[derive(Serialize)]
struct OpenAIRequest {
    model: String,
    messages: Vec<OpenAIMessage>,
}
#[derive(Deserialize)]
struct OpenAIChoice {
    message: OpenAIMessage,
}
#[derive(Deserialize)]
struct OpenAIResponse {
    choices: Vec<OpenAIChoice>,
}
pub fn ask_openai(prompt: &str) -> Result<String, String> {
    let config = get_config();
    let client = reqwest::blocking::Client::new();
    let url = "https://api.openai.com/v1/chat/completions";
    let request_body = OpenAIRequest {
        model: "gpt-3.5-turbo".to_string(),
        messages: vec![
            OpenAIMessage {
                role: "user".to_string(),
                content: prompt.to_string(),
            },
        ],
    };
    let response = client
        .post(url)
        .bearer_auth(&config.bot_apikey)
        .header("Content-Type", "application/json")
        .json(&request_body)
        .send()
        .map_err(|e| format!("HTTP error: {}", e))?;
    if !response.status().is_success() {
        return Err(format!("OpenAI error: {}", response.status()));
    }
    let parsed: OpenAIResponse = response
        .json()
        .map_err(|e| format!("Parse error: {}", e))?;
    let reply = parsed
        .choices
        .first()
        .map(|c| c.message.content.clone())
        .unwrap_or_else(|| "(no response)".to_string());
    Ok(reply)
}
